---
layout: post
title: "Procedural dungeon stress test, part 2"
date: 2024-12-06 00:00:00.000000000 +00:00
type: post
parent_id: '0'
published: true
password: ''
status: publish
categories:
- random
tags: []
image: assets/2024/12/stress_test2.png
meta:
author:
permalink: "/2024/12/06/procedural-dungeon-stress-test-part-2/"
---

<figure><img src="{{ site.baseurl }}/assets/2024/12/new_fov.png" alt="New FoV for map showoff purposes"/><br />
<figcaption>New FoV for map showoff purposes</figcaption>
</figure>

<p>More stress testing this week! First of all, I created a special FoV mode were all potentially visible tiles are uncovered, including any visibility blocking neighbours. This results in better-looking revealed maps (imo). Picture above! Everything is still destructible, but inner blocked areas (in black) are hidden</p>
<p>Next was tackling the buggy map with no exits. I dusted some old code that did validation checks (connectivity, map borders, etc), I integrated that at the end of the dungeon generation process, and I got some nice validation again. This was followed by a couple (part-time) days of debugging code due to failing validations and code fixes that avoid these failures. So finally, map generation got super stable (at least for this one single preset I&#39;m using)</p>
<p>Next was rerunning the test. I realized that the editor executable grows huge very quickly, and that&#39;s mostly because of all the debugger output, that includes meaty stack traces. So I set the log level to exception and tried again. </p>
<p>I finally got the test to complete successfully, about 4000 dungeons! The executable was at ~6GB. I immediately proceeded to save the state, because the data would be super-valuable for performance measurements, memory usage etc. A goldmine! Well, that did work out well. I got a crash in the serialization process (saving the game to the file). But why? My projections had said that the savefile would be about 170MB max. Well, I forgot that this value is the COMPRESSED LZ4 value, not the uncompressed one. But how much is the uncompressed size after 4000 levels? Well, I don&#39;t want to run the bot again, as it takes 30 minutes, I&#39;d rather do a bit of math. I put some breakpoints here and there, and adjusted the bot to save to file every 20 levels. After about 350 levels, I got some data points for (compressed, uncompressed). For example, at 340 levels, uncompressed save file is 233MB, and compressed is 23MB. Besides being happy about compression, I&#39;m realizing that after 4000 levels, the uncompressed file is over 2.1GB, compressing to supposedly something like 140MB. But 2.1GB exceed the max integer value, and the error that I got was &quot;System.GC.AllocateUninitializedArray(int, bool): System.OverflowException: Arithmetic operation resulted in an overflow.&quot;. That &quot;int&quot; there was the proof I needed. It&#39;s memory allocation, use some bloody unsigned numbers silly C#! It&#39;s like we&#39;re not supposed to do anything intensive with it. Apparently it was a conscious design decision to limit objects at 2GB. And apparently you can override that behaviour by setting <a href="https://learn.microsoft.com/en-us/dotnet/framework/configure-apps/file-schema/runtime/gcallowverylargeobjects-element?redirectedfrom=MSDN">some NET configuration option</a>. To make matters more complex, that option is set in a file that is auto-generated by Godot and I have no control over! Oh the joy. So, anyway, that&#39;s the state on that front.</p>
<p>I edited the bot to save every 500 dungeons visited. Last useful I got is 3500 dungeons visited, the savefile is 142MB at takes 19 seconds to load in the editor - a problem for another time! But, when loading the savefile the performance is much better than having gone through all 3500 dungeons in one go, which is quite nice.</p>
<p>Another thing, that needed a bit of time, but was totally worth it, was to add support to create a dungeon in-game from a json file. To clarify, the way things worked before were: when we create a &quot;dungeon&quot; in the overworld, it&#39;s just the specification. When we enter the dungeon, a more complex level-specification is being built on the fly, and converted to json. This json is sent to the C++ plugin where it&#39;s read, and used to instantiate the dungeon. The dungeon is a lightweight bytestream, which is received in C# and gets instantiated. What I did now was to support creating a new dungeon in the overworld that instantiates a single level using a given json. The reason I do that is that, when I identify a json that leads to validation failure in the native plugin, I fix the issues so that it passes, and then reload that json in the game to ensure everything&#39;s alright there too.</p>
<p>And that&#39;s all for this week, have a nice weekend!</p>

