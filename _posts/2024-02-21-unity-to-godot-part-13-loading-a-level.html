---
layout: post
title: "Unity to Godot part 13: Loading a level"
date: 2024-02-21 00:00:00.000000000 +00:00
type: post
parent_id: '0'
published: true
password: ''
status: publish
categories:
- random
tags: []
image: assets/2024/02/weather.png
meta:
author:
permalink: "/2024/02/21/unity-to-godot-part-13-loading-a-level/"
---

<figure>
<div class="video-container"><iframe src="https://www.youtube.com/embed/vapDfykGODM" allowfullscreen="" frameborder="0" srcdoc="<style>*{padding:0;margin:0;overflow:hidden}html,body{height:100%}img,span{position:absolute;width:100%;top:0;bottom:0;margin:auto}span{height:1.5em;text-align:center;font:48px/1.5 sans-serif;color:white;text-shadow:0 0 0.5em black}</style><a href=https://www.youtube.com/embed/vapDfykGODM ?autoplay=1><img src=https://img.youtube.com/vi/vapDfykGODM/hqdefault.jpg alt='video play button'><span>&#x25BA;</span></a>" loading="lazy" title="Level ambience"></iframe></div>
<figcaption>Level ambience</figcaption>
</figure>

<p>More porting work this week, this time aiming to get into a level from the overworld. Spoiler alert: level is loaded, and some of the graphics are ported too. Video above. Some of the things that got done, relevant or not:</p>
<ul>
<li><strong>Refactor C++ bindings generator</strong>. I have a C++ plugin bindings generator written in python, that generates a C# file with all function signatures. It&#39;s a code generator rather than a simple file because with Unity there were some tedious #ifdefs and different ways of handling things. Now, even though the bindings specification is simpler, the script still makes things easier, so I made sure it works identically to how it did, fixing a few bugs on the way</li>
<li><strong>Allow disabling AI globally with a checkbox</strong>. This was one of the &quot;Why did I not have this earlier?&quot; moments, and the need came because the game now crashes when some entities attack each other, but I wanted to focus on graphics, so I needed a way to shut everyone up without killing them, so with the addition of this button the AI now can always just skip turn. Super useful.</li>
<li><strong>Allow granular render pass control</strong>. It&#39;s super useful to only render a subset of passes, especially when debugging graphics and trying to figure out the source of some artifacts. So, thanks to ImGUI and Godot&#39;s open architecture, I can list all my renderpasses and allow enabling/disabling each one. As a reminder, I&#39;ve got a custom rendering pipeline so I have full control (and responsibility) of what&#39;s rendered when.</li>
<li><strong>GPU buffer refactor</strong>. I had made some design fart where resources that needed serialization contained actual GPU resources such as GPU buffers, so I did another pass and now buffers are &quot;rented&quot; from a central graphics resources object. Bonus: I know what resources are allocated at any given time.</li>
<li><strong>Graphics resources inspector</strong>. I have a &quot;graphics resource database&quot; where I put loaded textures, buffers etc. I&#39;ve implemented some ImGUI display for the database too so I can check what&#39;s loaded</li>
<li><strong>Humble audio and Sound Explorer</strong>. I got tempted by some humble bundle for audio music and sfx, so I bought that. One of my PhD students suggested to me an application called Sound Explorer, for managing audio files. Due to other more pressing work, this is all waiting in the background, but I do want to have a go at adding more audio soon.</li>
<li><strong>Fixed a mean graphics glitch</strong>. In the past, and also at some point this week, I got a mean graphics glitch that manifested as horizontal or vertical thin lines in the game area at tile borders. This was because of some custom hacky code to handle Unity&#39;s stupid sampler limitation, where you can&#39;t have separate minification and magnification filters. But now in Godot, because it exposes the low-level stuff, I can finally select trilinear filter for minification and point filter for magnification. I think that&#39;s great for pixel art as the minification is not noisy (but gets blurrier; such is life) and magnification is nice and crispy. </li>
<li><strong>Fixed liquids in levels</strong>. Liquids in levels are a bit different to the overworld and also a bit special, so some work was put to port that shader. Still some related work to be done.</li>
<li><strong>Hover-over info tooltips</strong>. Thanks to ImGUI again, I&#39;ve added a tooltip with tile information when hovering over a tile and holding F1. Currently it&#39;s the info generated by the dungeon generator, but needs to be replaced with more rich information</li>
<li><strong>Layout buffer equality source generation</strong>. I&#39;m using layout buffers for vulkan shaders, and they have C# equivalent structs that I can use to convert to bytes and upload to GPU. For a few reasons, it&#39;s useful to be able to quickly compare buffer contents, so I wrote some code to generate equality testing code. It&#39;s a bit tedious in C#, having to implement 3 functions, but it&#39;s easily automated at least.</li>
<li><strong>Fog of war port</strong>. This was the heavy hitter of the week, since it&#39;s a complex shader that adds funky fog of war, time-of-day color gradients and explored/currently-seen visualisation, in addition to support for heat haze, actual fog, darkvision and lightning effects. After a bit of sweat, it&#39;s done, and you can see the results at the video above. The colours I think are different to what they used to be, and I&#39;m not sure if it&#39;s related to sRGB vs linear texture, although I can&#39;t see such option in Godot.</li>
<li><strong>Border rendering order</strong>. I used to draw the border before sprites such as trees and mountains, but after adding fog of war, this ended up occasionally revealing trees/mountains near borders (overlapping borders). So I moved borders after such sprites and before fog of war.</li>
</ul>
<p>That&#39;s it for now, phew! It&#39;s SO much work, but the port is moving ahead, always.</p>

