---
layout: post
title: Overworld Territories
date: 2018-07-21 23:01:30.000000000 +01:00
type: post
parent_id: '0'
published: true
password: ''
status: publish
categories:
- random
tags: []
meta:
  _edit_last: '1'
  _wpas_done_all: '1'
  _jetpack_related_posts_cache: a:1:{s:32:"8f6677c9d6b0f903e98ad32ec61f8deb";a:2:{s:7:"expires";i:1619516635;s:7:"payload";a:3:{i:0;a:1:{s:2:"id";i:1945;}i:1;a:1:{s:2:"id";i:2883;}i:2;a:1:{s:2:"id";i:2257;}}}}
  rank_math_internal_links_processed: '1'
  rank_math_analytic_object_id: '46'
author:
permalink: "/2018/07/21/overworld-territories/"
---
<h3><img class="imgc" src="{{ site.baseurl }}/assets/2018/07/terrshot0.webp" alt="" width="512" height="512" /> <img class="imgc" src="{{ site.baseurl }}/assets/2018/07/terrshot1.webp" alt="" width="512" height="512" /></h3>
<h3></h3>
<h3></h3>
<h3></h3>
<h3></h3>
<h3></h3>
<h3></h3>
<h3></h3>
<h3></h3>
<h3></h3>
<h3></h3>
<h3></h3>
<h3></h3>
<h3></h3>
<h3></h3>
<h3>City-States</h3>
<p><a href="{{ site.baseurl }}/2018/07/15/nations-races-and-cities/">City-states rule the world</a>. For the whole overworld, using my current projections, there will be a maximum of about 250 cities. For a <a href="{{ site.baseurl }}/2017/12/14/overworld-map-generation/">512x512 overworld</a>, this would be very roughly a city per 32x32 grid.  Given that a grid cell would represent about 10 sq km, this mean a very sparsely populated overworld, which doesn't resemble the Middle Ages all that much. That's fine though, as the alternative/realistic version would be a city/town/hamlet per grid tile, and that would make a quarter of a million such towns.</p>
<h3>Borders and growth</h3>
<p>City-states have areas of influence, which define their territory and borders.  The area of influence is directly related to how difficult is to cross the terrain. In that sense, sea and high mountains are in general more difficult than other terrains, and the difficulty only increases in temperature/humidity/vegetation extremes. With that in mind, we can create an "influence cost map", which dictates how influence, generated by its sources (cities at the moment), is reduced while radiating outwards.</p>
<h3>Borders between city states</h3>
<p>Another interesting point is how to deal with borders between city-states. I found that the simple way of "whoever exerts greater influence on the tile, owns the tile" is unsatisfactory, as city-states with even slightly greater influence can quickly overcome the whole territory of another city state. For example, a city state gains 4% influence, and suddenly it wins over 60% of another city state's total territory. To deal with that, I still compare the influences, but they are scaled by a factor related to the inverse squared distance of the grid cell in question to the city states: tiles close to city-states (and owned by them)  are much more difficult to be won over by some other city state, especially if it's far away.</p>
<h3>Algorithm</h3>
<p>A couple of years ago I developed an algorithm for this, with "nations" in mind (a max of 16 of them). The algorithm was fast, a bit buggy and complicated. Also, code was messy. I tried to read and understand it, and realized I'd be better off writing something from scratch, and it had to be simple. As an attempt of documentation here's the algorithm in all its glory.</p>
<h3>Data format</h3>
<p>First things first. For each tile, we store the source ID and the influence decay so far, from the source location until the tile. The decay will be the accumulation of decays along the "shortest" 8-connected path starting from the source.</p>
<h3>Initialization</h3>
<p>Create the influence decay map, that stores for each tile how much influence is reduced on crossing the tile horizontally or vertically (for diagonal crossing, it's scaled by sqrt(2) )</p>
<h3>Adding/Removing/Changing an influence source</h3>
<p>All these cases are handled mostly in the same way, which important for simplicity.</p>
<p><strong>-&gt; Update local cache</strong></p>
<p>We keep a very small per-source cache that stores the location and influence of each source -- that's it. We update the cache by adding/removing/modifying entries as needed</p>
<p><strong>-&gt; Calculate front</strong></p>
<p>We calculate all the border tiles of a source in the following way. We start with the influence source location (the city), and we slowly expand outwards the 4 directions (left, right, top,bottom). We expand towards a direction if a point is within the influence of the source. Below is an image that represents this outwards expansion (the center of the concentric squares is the influence source). In the image, I mark the boundary points; these are the points that have at least one neighbour that is outside the source's influence (they could belong to a different city, or they might be neutral). <strong>So, we slowly grow this axis aligned bounding box of the source's points, while adding all the border points to a "to process" list.</strong></p>
<p><img class="imgc" src="{{ site.baseurl }}/assets/2018/07/borders_00867.webp" alt="" width="512" height="512" /></p>
<p>&nbsp;</p>
<p><strong>-&gt; Process queue</strong></p>
<p>We have now a queue with a list of points to be processed. These are all the boundary points (For a newly created source, it's location is the one and single boundary point). The queue is a  <strong>priority queue: </strong>we add points accompanied by weights, where the weights represent how important it is to process the points first. The reason why a priority queue is important is because we want to avoid traversing tiles multiple times. Imagine the following scenario:</p>
<ul>
<li>Tile (32,45) needs to be processed. We figure out that it should belong to source S0, and it will have an influence of 50</li>
<li>...</li>
<li>Tile (32,45) needs to be processed again. Because we arrived here from a different path, we realize that it should actually belong to source S1, and it will have an influence of 62</li>
<li>...</li>
<li>Tile (32,45) needs to be processed again. We arrived from a different path again, but from the same source ( so effectively used a shortcut, e.g. around the mountains that cost much to pass through). So, while it will still belong to source S1, it will now have an influence of 65.</li>
</ul>
<p>So, a tile can be unnecessarily processed several times, while we can avoid that if we process the last one first (S1, 65 influence), as the others simply have lesser influence and will not cause the tile to get re-processed. The above also hints on how the processing is done: as a form of <strong>floodfill</strong>. While on a tile, we figure out who the owner is, how much influence is there at the tile (source influence - influence decay till point), and which neighbouring tiles do we need to process. The queue processing algorithm can be summarized as follows:</p>
<ul>
<li>Get the top point in the queue</li>
<li>Check if it's obsolete. It would be obsolete if the stored weight is lower than the current weight (the weights are just the influence values). If it's obsolete, repeat from above</li>
<li>Check the 8 neighbours and calculate the scores as if the neighbours owned the tile. So, we pretty much calculate if they <strong>should </strong>own it</li>
<li>If our influence is negative and there's no better neighbour, the tile needs to be reclaimed by nature. If that's the case, add to the queue all neighbours that are of the same source</li>
<li>If our influence is positive and there's no better neighbour, we're ok and we need to see if we need to expand this source id to neighbouring tiles. By comparing influences, we add potential candidates to the queue.</li>
<li>If there's a better neighbour, we replace this tile. The new influence information can propagate further, so we check all neighbours to find out potential processing candidates and add them to the queue.</li>
</ul>
<h3>Video</h3>
<p>Here's a video that demonstrates border growth for 256 city states.</p>
<p>&nbsp;</p>
<div class="video-container">
	<iframe src="https://www.youtube.com/embed/sHKJ5cdLiUA" allowfullscreen="" frameborder="0" srcdoc="<style>*{padding:0;margin:0;overflow:hidden}html,body{height:100%}img,span{position:absolute;width:100%;top:0;bottom:0;margin:auto}span{height:1.5em;text-align:center;font:48px/1.5 sans-serif;color:white;text-shadow:0 0 0.5em black}</style><a href=https://www.youtube.com/embed/sHKJ5cdLiUA?autoplay=1><img src=https://img.youtube.com/vi/sHKJ5cdLiUA/hqdefault.jpg alt='video play button'><span>&#x25BA;</span></a>" loading="lazy" title="Showing youtube video sHKJ5cdLiUA"></iframe>
</div>
